
#include "class.h"


/*================================================*/
//函数定义
/*================================================*/
/**************************************************************************************************
* 函数原型 : void setmem(UCHAR* pmem, UCHAR init_val, UINT length)
* 功    能 : 初始化内存初值
* 入口参数 : 
* 出口参数 : void
* 返    回 : void
* 全局变量 : 
* 创建日期 : 2008-01-06
* 版	本 : V0.01.20080106
* 说    明 : 
**************************************************************************************************/
void setmem(u8* pmem, u8 init_val, u16 length)
{
    u16 i;
    
    for (i = 0; i < length; i++)
    {
       pmem[i] = init_val;
    }
}

/**************************************************************************************************
* 函数原型 : void cpymem(UCHAR* pmem, PUCHAR sval, UINT length)
* 功    能 : 拷贝内存
* 入口参数 : 
* 出口参数 : void
* 返    回 : void
* 全局变量 : 
* 创建日期 : 2008-01-06
* 版	本 : V0.01.20080106
* 说    明 : 
**************************************************************************************************/
void cpymem(u8* pmem, u8* sval, u16 length)
{
    u16 i;
    
    for (i = 0; i < length; i++)
    {
        pmem[i] = sval[i];
    }
}

/**************************************************************************************************
* 函数原型 : UINT cpystr(PUCHAR pdmem, PUCHAR psmem)
* 功    能 : 字符串拷贝
* 入口参数 : 
* 出口参数 : void
* 返    回 : void
* 全局变量 : 
* 创建日期 : 2008-01-06
* 版	本 : V0.01.20080106
* 说    明 : 
**************************************************************************************************/
u16 cpystr(u8* pdmem, u8* psmem)
{
    u16 i;
    
    for (i = 0; psmem[i] != '\0'; i++)
    {
        pdmem[i] = psmem[i];
    }
    
    return i;
}

/**************************************************************************************************
* 函数原型 : UCHAR cmpmem(UCHAR* pmem, PUCHAR sval, UINT length)
* 功    能 : 比较内存
* 入口参数 : 
* 出口参数 : void
* 返    回 : 
* 全局变量 : 
* 创建日期 : 2008-01-06
* 版	本 : V0.01.20080106
* 说    明 : 
**************************************************************************************************/
u8 cmpmem(u8* pmem, u8* sval, u16 length)
{
    u16 i;
    
    for (i = 0; i < length; i++)
    {
        if (pmem[i] != sval[i])
        {
            return false;
        }		
    }
    
    return true;
}
/**************************************************************************************************
* 函数原型 : UCHAR cmpare_string(const UCHAR * cmpared_string, UCHAR* cmpare_string)
* 功    能 : 比较字符串
* 入口参数 : 
* 出口参数 : 
* 返    回 : 
* 全局变量 : 
* 创建日期 : 2008-01-06
* 版	本 : V0.01.20080106
* 说    明 : 
**************************************************************************************************/
u8 cmpare_string(uc8 * cmpared_string, u8* cmpare_string)
{
    u8 i = 0;
    u8 j = 0;
    
    //排除被比较字符串中的回车符
    do {
          if ((cmpared_string[i] == 0x0d) || (cmpared_string[i] == 0x0a))
          {
              i++;
          }
          else
          {
              break;
          }
    } while(1);
    
    //开始比较字符串
    for (j = 0; cmpare_string[j] != '\0'; j++)
    {
        if (cmpared_string[i++] != cmpare_string[j])
        {
            return false;
        }
    }
    
    return true;
}





/**************************************************************************************************
* 函数原型 : void run_led(void)
* 功    能 : 运行灯闪烁函数
* 入口参数 : UCHAR f_tim
* 出口参数 : void
* 返    回 : void
* 全局变量 : UINT g_led_cnt; //运行灯闪烁时间控制计数器
* 创建日期 : 2007-10-16
* 版	本 : V0.01.20071016
* 说    明 : 闪烁频率为1Hz
**************************************************************************************************/
/*void run_led(void)
{
			//喂狗
	//运行灯1S翻转1次
	if (DCD2_PIN)
	{
		if (g_led_cnt >= 500)
		{
			//g_led_cnt = 0xF0;	 //CPU运行在12时钟	
			g_led_cnt = 0x00;
			
			RUN_PIN ^= 1; //运行灯翻转
		}
	}
	else
	{
		if (RUN_PIN)
		{
			if (g_led_cnt >= 950)
			{
				//g_led_cnt = 0xF0;	 //CPU运行在12时钟	
				g_led_cnt = 0x00;
				
				RUN_PIN ^= 1; //运行灯翻转
			}
		}
		else
		{
			if (g_led_cnt >= 50)
			{
				//g_led_cnt = 0xF0;	 //CPU运行在12时钟	
				g_led_cnt = 0x00;
				
				RUN_PIN ^= 1; //运行灯翻转
			}
		}		
	}
	
	RTS2_PIN = 0;        //RTS置低，进行软件握手
}
*/
/**************************************************************************************************
* 函数原型 : void hextostr(UCHAR f_hex, PUCHAR f_str)
* 功    能 : 一个HEX数据转换成字符串数据
* 入口参数 : UCHAR f_hex 被转换的HEX数据
* 出口参数 : PUCHAR f_str 转换成的字符串数据地址
* 返    回 : 空
* 全局变量 : 无
* 创建日期 : 2008-04-14
* 版	本 : V0.01.20080414
* 说    明 : 
**************************************************************************************************/
void hex2str(u8 f_hex, u8* f_str)
{
    f_str[0] = f_hex%10 + 0x30;
    f_str[1] = (f_hex%100)/10 + 0x30;
    f_str[2] = f_hex/100 + 0x30;
    f_str[3] = '\0';
    mem_exchange(f_str, 3);
    inden_str(f_str);
}

/**************************************************************************************************
* 函数原型 : void shorttostr(UINT f_short, PUCHAR f_str)
* 功    能 : 一个短整型数据转换成字符串
* 入口参数 : UINT f_short 被转换的整型数据
* 出口参数 : PUCHAR f_str 转换成字符串的地址
* 返    回 : 空
* 全局变量 : 无
* 创建日期 : 2008-04-14
* 版	本 : V0.01.20080414
* 说    明 : 
**************************************************************************************************/
void short2str(u16 f_short, u8* f_str)
{	
    f_str[0] = f_short%10 + 0x30;
    f_str[1] = (f_short%100)/10 + 0x30;
    f_str[2] = (f_short%1000)/100 + 0x30;
    f_str[3] = (f_short%10000)/1000 + 0x30;
    f_str[4] = f_short/100000 + 0x30;
    f_str[5] = '\0';
    mem_exchange(f_str, 5);
    inden_str(f_str);
}
/**************************************************************************************************
* 函数原型 : void mem_exchange(PUCHAR f_pmem, UCHAR f_num)
* 功    能 : 使一段连续内存中的数据前后调换
* 入口参数 : UCHAR f_num 要调换内存的字节数
* 出口参数 : PUCHAR f_pmem 被调换的内存地址
* 返    回 : 空
* 全局变量 : 无
* 创建日期 : 2008-04-14
* 版	本 : V0.01.20080414
* 说    明 : 
**************************************************************************************************/
void mem_exchange(u8* f_pmem, u8 f_num)
{
    u8 i,j, l_tmp;
    
    j = f_num -1;
    f_num /= 2;
    for (i=0;i<f_num;i++)
    {
        l_tmp = f_pmem[i];
        f_pmem[i] = f_pmem[j];
        f_pmem[j--] = l_tmp;
    }
}

/**************************************************************************************************
* 函数原型 : void byte_exchange(PUCHAR f_pmem, UCHAR f_num)
* 功    能 : 在内在中前后调换
* 入口参数 : UCHAR f_num 要调换内存的字节数
* 出口参数 : PUCHAR f_pmem 被调换的内存地址 
* 返    回 : 空
* 全局变量 : 无
* 创建日期 : 2008-04-26
* 版	本 : V0.01.20080426
* 说    明 : 
**************************************************************************************************/
void parity_exchange(u8* f_pmem, u8 f_num)
{
	u8 i, l_tmp;

	for (i=0;i<f_num;i++)
	{
            l_tmp = f_pmem[i];
            f_pmem[i] = f_pmem[i+1];
            f_pmem[++i] = l_tmp;
	}
}

/**************************************************************************************************
* 函数原型 : void inden_str(PUCHAR f_str)
* 功    能 : 整理以字符'0'开头的字符串
* 入口参数 : 无
* 出口参数 : PUCHAR f_str 被整理的字符串
* 返    回 : 无
* 全局变量 : 无
* 创建日期 : 2008-04-14
* 版	本 : V0.01.20080414
* 说    明 : 比如"0123"整理成"123"
**************************************************************************************************/
void inden_str( u8* f_str)
{
    s8 i,l_tmp;
    
    l_tmp = strlen((const char *)f_str);
    
    for (i=0;i<l_tmp;i++)
    {
        if (f_str[0] == '0')
        {
            move_str(f_str,LEFT_MOVE,1);
        }
    }
}

/**************************************************************************************************
* 函数原型 : void move_str(PUCHAR f_str,UCHAR f_mve_dir, UCHAR f_mve_num)
* 功    能 : 向左或向右移动字符串
* 入口参数 : UCHAR f_mve_dir 移动方向(0 左移, 1 右移)
			 UCHAR f_mve_num 移动位数
* 出口参数 : PUCHAR f_str 被移动的字符串
* 返    回 : 空
* 全局变量 : 无
* 创建日期 : 2008-04-14
* 版	本 : V0.01.20080414
* 说    明 : 
**************************************************************************************************/
void move_str(u8* f_str,u8 f_mve_dir, u8 f_mve_num)
{
    s8 i,l_tmp;
    
    l_tmp = strlen((const char *)f_str) - f_mve_num;
    
    if (f_mve_dir) //右移
    {
        f_str[l_tmp] = '0';
    }
    else		   //左移
    {
        for (i=0;i<l_tmp;i++)
        {
            f_str[i] = f_str[i+f_mve_num];
        }
        f_str[i] = '\0';
    }
}


/**************************************************************************************************
* 函数原型 : UCHAR sbuftobcd(PUCHAR  f_sbuf, UINT* f_bcd)
* 功    能 : 把缓存中连续的数字字母转换成BCD码
* 入口参数 : PUCHAR f_sbuf	缓存地址
* 出口参数 : UINT* f_bcd	转换成的BCD码地址
* 返    回 : 缓存中转换的数字字母个数
* 全局变量 : 无
* 创建日期 : 2008-04-22
* 版	本 : V0.01.20080422
* 说    明 : 
**************************************************************************************************/
u8 sbuf2bcd(u8*  f_sbuf, u16* f_bcd)
{
    u8 i;
    
    *f_bcd = 0;
    for (i=0;i<4;i++)
    {
        if ((f_sbuf[i] >= '0')&&(f_sbuf[i] <= '9'))
        {
            *f_bcd <<= 4;
            *f_bcd += f_sbuf[i] - '0';
        }
        else
        {
            return i;
        }
    }
    return i;
}

/**************************************************************************************************
* 函数原型 : UCHAR bcdtohex(UINT f_bcd)
* 功    能 : 把(255-0)范围内的BCD转换成HEX码
* 入口参数 : UINT f_bcd	被转换的BCD码
* 出口参数 : 无
* 返    回 : 转换成的HEX码
* 全局变量 : 无
* 创建日期 : 2008-05-07
* 版	本 : V0.01.20080507
* 说    明 : 
**************************************************************************************************/
u8 bcd2hex(u16 f_bcd)
{
    u8 l_tmp;
    l_tmp = ((f_bcd >> 8) % 3) * 100;
    l_tmp += ((f_bcd & 0xF0) >> 4) * 10;
    l_tmp += (f_bcd & 0x0F);
    return l_tmp;
}

/**************************************************************************************************
* 函数原型 : UCHAR chartohex(PUCHAR f_pchar)
* 功    能 : 把两位字符CHAR转换成HEX码
* 入口参数 : PUCHAR f_pchar	被转换的字符CHAR的指针
* 出口参数 : 无
* 返    回 : 转换成的HEX码
* 全局变量 : 无
* 创建日期 : 2008-05-09
* 版	本 : V0.01.20080509
* 说    明 : 
**************************************************************************************************/
u8 char2hex(u8* f_pchar)
{
    u8 l_tmp;
    
    l_tmp = (f_pchar[0] > '9' ? f_pchar[0] - '7' : f_pchar[0] - '0')  << 4;
    l_tmp |= (f_pchar[1] > '9' ? f_pchar[1] - '7' : f_pchar[1] - '0') & 0x0F;
    return l_tmp;
}
